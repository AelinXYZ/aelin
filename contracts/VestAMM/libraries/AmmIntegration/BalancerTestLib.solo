// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
pragma experimental ABIEncoderV2;

import {IVault} from "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
import {WeightedPoolUserData} from "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IAsset {
    function decimals() external view returns (uint8);
}

interface IWeightedPoolFactory {
    struct CreatePoolParams {
        string name;
        string symbol;
        IERC20[] tokens;
        uint256[] normalizedWeights;
        address[] rateProviders;
        uint256 swapFeePercentage;
        address owner;
        bytes32 salt;
    }

    function create(
        string memory name,
        string memory symbol,
        IERC20[] memory tokens,
        uint256[] memory normalizedWeights,
        address[] memory rateProviders,
        uint256 swapFeePercentage,
        address owner,
        bytes32 salt
    ) external returns (address);
}

contract BalancerVestAMM {
    IWeightedPoolFactory internal immutable weightedPoolFactory;
    IVault internal immutable balancerVault;
    bytes32 public poolId;

    constructor(address _vault, address _weightedPoolFactory) {
        balancerVault = IVault(_vault);
        weightedPoolFactory = IWeightedPoolFactory(_weightedPoolFactory);
    }

    function createPool(IWeightedPoolFactory.CreatePoolParams calldata _poolData) public returns (address) {
        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(1));
        tokens[1] = IERC20(address(1));

        uint256[] memory weights = new uint256[](2);
        weights[0] = 500000000000000000;
        weights[1] = 500000000000000000;

        address[] memory rateProviders = new address[](2);
        rateProviders[0] = address(0);
        rateProviders[1] = address(0);
        return
            weightedPoolFactory.create(
                "Linuz Test",
                "LNZ",
                tokens, //_poolData.tokens,
                weights, //50% - 50% //_poolData.normalizedWeights,
                //_poolData.rateProviders,
                // https://docs.balancer.fi/reference/contracts/rate-providers.html
                rateProviders,
                2500000000000000, //_poolData.swapFeePercentage, 2,5%
                address(this),
                _poolData.salt // ???
            );
    }

    /**
     * This function demonstrates how to initialize a pool as the first liquidity provider
     * So the pool already exists and we're just adding the initial liquidity
     */
    function initializePool(bytes32 _poolId) public {
        // Some pools can change which tokens they hold so we need to tell the Vault what we expect to be adding.
        // This prevents us from thinking we're adding 100 DAI but end up adding 100 BTC!
        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(_poolId);
        IAsset[] memory assets = _convertERC20sToAssets(tokens);

        // These are the slippage limits preventing us from adding more tokens than we expected.
        // If the pool trys to take more tokens than we've allowed it to then the transaction will revert.
        uint256[] memory maxAmountsIn = new uint256[](tokens.length);
        for (uint256 i; i < tokens.length; i++) {
            maxAmountsIn[i] = type(uint256).max;
        }

        // There are several ways to add liquidity and the userData field allows us to tell the pool which to use.
        // Here we're encoding data to tell the pool we're adding the initial liquidity
        // Balancer.js has several functions can help you create your userData.
        bytes memory userData = abi.encode(
            WeightedPoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
            maxAmountsIn,
            500000000000000000
        );

        // We can ask the Vault to use the tokens which we already have on the vault before using those on our address
        // If we set this to false, the Vault will always pull all the tokens from our address.
        bool fromInternalBalance = false;

        // We need to create a JoinPoolRequest to tell the pool how we we want to add liquidity
        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: maxAmountsIn,
            userData: userData,
            fromInternalBalance: fromInternalBalance
        });

        // We can tell the vault where to take tokens from and where to send BPT to
        // If you don't have permission to take the sender's tokens then the transaction will revert.
        // Here we're using tokens held on this contract to provide liquidity and forward the BPT to msg.sender
        address sender = address(this);
        address recipient = msg.sender;

        balancerVault.joinPool(_poolId, sender, recipient, request);
    }

    /**
     * @dev This helper function is a fast and cheap way to convert between IERC20[] and IAsset[] types
     */
    function _convertERC20sToAssets(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            assets := tokens
        }
    }
}
